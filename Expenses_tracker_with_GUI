
import json
import os
from datetime import datetime, timedelta
import pandas as pd
import tkinter as tk
from tkinter import messagebox, simpledialog, filedialog, ttk


categories = {"groceries": 0, "transportation": 0, "entertainment": 0, "utilities": 0}
custom_categories = {}
expenses = []

# GUI Colors
BG_COLOR = "#f0f0f0"
BUTTON_COLOR = "#4CAF50"
BUTTON_HOVER = "#45a049"
TEXT_COLOR = "#333333"
HEADER_COLOR = "#2196F3"
WINDOW_WIDTH = 500
WINDOW_HEIGHT = 550

def parse_date_input(date_input):
    """Parse flexible date input formats and convert to YYYY-MM-DD"""
    if not date_input:
        return None
    
    date_input = date_input.strip()
    today = datetime.now()
    
    # If just DD (e.g., "15")
    if date_input.isdigit() and len(date_input) <= 2:
        try:
            day = int(date_input)
            if 1 <= day <= 31:
                # Use current year and month
                year = today.year
                month = today.month
                # Validate date (handles invalid days like Feb 30)
                try:
                    test_date = datetime(year, month, day)
                    return test_date.strftime("%Y-%m-%d")
                except ValueError:
                    return None
        except ValueError:
            pass
    
    parts = date_input.split('-')
    
    # If YYYY-MM-DD, normalize and return
    if len(parts) == 3 and len(parts[0]) == 4:
        try:
            year = int(parts[0])
            month = int(parts[1])  # Handles both "1" and "01"
            day = int(parts[2])    # Handles both "1" and "01"
            # Validate date
            datetime(year, month, day)
            return f"{year:04d}-{month:02d}-{day:02d}"
        except (ValueError, IndexError):
            return None
    
    # If YY-MM-DD (e.g., "24-01-15" or "24-1-15")
    if len(parts) == 3 and len(parts[0]) <= 2:
        try:
            year = int(parts[0])
            month = int(parts[1])  # Handles both "1" and "01"
            day = int(parts[2])      # Handles both "1" and "01"
            # Convert YY to 20YY
            full_year = 2000 + year if year < 100 else year
            # Validate date
            datetime(full_year, month, day)
            return f"{full_year:04d}-{month:02d}-{day:02d}"
        except (ValueError, IndexError):
            return None
    
    # If MM-DD (e.g., "01-15" or "1-15")
    if len(parts) == 2:
        try:
            month = int(parts[0])  # Handles both "1" and "01"
            day = int(parts[1])    # Handles both "1" and "01"
            if 1 <= month <= 12 and 1 <= day <= 31:
                # Use current year
                year = today.year
                # Validate date
                datetime(year, month, day)
                return f"{year:04d}-{month:02d}-{day:02d}"
        except (ValueError, IndexError):
            return None
    
    return None

def le():
    global expenses, custom_categories
    if os.path.exists('expenses.json'):
        with open('expenses.json', 'r') as file:
            data = json.load(file)
            expenses = data.get('expenses', [])
            custom_categories = data.get('custom_categories', {})

def se():
    with open('expenses.json', 'w') as file:
        data = {'expenses': expenses, 'custom_categories': custom_categories}
        json.dump(data, file)

def am():
    category = cc()
    if not category:
        messagebox.showerror("Error", "Invalid category. Please choose again.", parent=root)
        return

    amount_str = ask_string_input("Add Expense", "Enter the amount spent:", root)
    if amount_str is None:
        return
    try:
        amount = float(amount_str)
    except ValueError:
        messagebox.showerror("Error", "Invalid format.", parent=root)
        return

    description = ask_string_input("Add Expense", "Enter a brief description:", root)
    if description is None:
        return

    date_input = ask_string_input("Add Expense", "Enter the date (YYYY-MM-DD or DD or YY-MM-DD or MM-DD):", root)
    if date_input is None:
        return
    
    date = parse_date_input(date_input)
    if date is None:
        try:
            # Try standard format as fallback
            date = datetime.strptime(date_input, "%Y-%m-%d").strftime("%Y-%m-%d")
        except ValueError:
            messagebox.showerror("Error", "Invalid date format. Please enter date as:\n- DD (day only)\n- YY-MM-DD (e.g., 24-01-15)\n- MM-DD (e.g., 01-15)\n- YYYY-MM-DD", parent=root)
            return

    expenses.append({'amount': amount, 'description': description, 'category': category, 'date': date})
    messagebox.showinfo("Success", "Expense recorded successfully.", parent=root)

def ete():
    df = pd.DataFrame(expenses)
    
    filename = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel files", "*.xlsx")])
    if filename:
        df.to_excel(filename, index=False, engine='openpyxl')
        messagebox.showinfo("Export", f"Expenses exported to {filename}.")

def cc():
    all_categories = {**categories, **custom_categories}
    category_list = list(all_categories.keys())
    
    while True:
        prompt = "\n".join([f"{idx + 1}. {category.capitalize()}" for idx, category in enumerate(category_list)])
        prompt += f"\n{len(category_list) + 1}. Add Custom Categories"
        choice = ask_integer_input("Select Category", prompt, root)
        
        if choice is None:
            return None
        
        if choice == len(category_list) + 1:
            # User wants to manage categories
            manage_categories()
            # Refresh category list after management
            all_categories = {**categories, **custom_categories}
            category_list = list(all_categories.keys())
            # Continue loop to show updated list
            continue
        
        if choice and 1 <= choice <= len(category_list):
            return category_list[choice - 1]
        
        messagebox.showerror("Error", "Invalid selection. Please choose again.", parent=root)

def vs():
    total_expense = sum(expense['amount'] for expense in expenses)
    summary = f"Total Expenses: ‚Çπ{total_expense:.2f}\n\n"

    cs = {}
    for expense in expenses:
        category = expense['category']
        if category in cs:
            cs[category] = cs[category] + expense['amount']
        else:
            cs[category] = expense['amount']

    summary += "Expenses by Category:\n"
    for category, amount in cs.items():
        summary += f"{category.capitalize()}: ‚Çπ{amount:.2f}\n"

    for category, total in cs.items():
        count = sum(1 for expense in expenses if expense['category'] == category)
        average = total / count if count > 0 else 0
        summary += f"Average spending for {category.capitalize()}: ‚Çπ{average:.2f}\n"

    highest_category = max(cs, key=cs.get)
    lowest_category = min(cs, key=cs.get)
    summary += f"\nCategory with highest expenses: {highest_category.capitalize()} (‚Çπ{cs[highest_category]:.2f})\n"
    summary += f"Category with lowest expenses: {lowest_category.capitalize()} (‚Çπ{cs[lowest_category]:.2f})\n"

    messagebox.showinfo("Summary", summary)

def vep():
    period_input = ask_string_input("View Expenses", "Enter the period (daily/weekly/monthly):", root)
    if period_input is None:
        return
    period = period_input.strip().lower()

    if period == 'daily':
        date_input = ask_string_input("View Expenses", "Enter the specific date (YYYY-MM-DD or DD or YY-MM-DD or MM-DD):", root)
        if date_input is None:
            return
        
        specific_date = parse_date_input(date_input)
        if specific_date is None:
            try:
                # Try standard format as fallback
                specific_date = datetime.strptime(date_input, "%Y-%m-%d").strftime("%Y-%m-%d")
            except ValueError:
                messagebox.showerror("Error", "Invalid date format. Please enter date as:\n- DD (day only)\n- YY-MM-DD (e.g., 24-01-15)\n- MM-DD (e.g., 01-15)\n- YYYY-MM-DD", parent=root)
                return

        fe = [expense for expense in expenses if expense['date'] == specific_date]
        if not fe:
            messagebox.showinfo("View Expenses", f"No expenses found for {specific_date}.", parent=root)
            return

        display_expenses(fe)

    elif period == 'weekly':
        mi = ask_string_input("View Expenses", "Enter the month (YYYY-MM):", root)
        if mi is None:
            return
        try:
            som = datetime.strptime(mi, "%Y-%m").replace(day=1)
            eom = (som + timedelta(days=31)).replace(day=1) - timedelta(days=1)
        except ValueError:
            messagebox.showerror("Error", "Invalid month format. Please enter the month in YYYY-MM format.", parent=root)
            return

        cws = som
        wn = 1

        while cws <= eom:
            we = cws + timedelta(days=6)
            if we > eom:
                we = eom

            fe = [expense for expense in expenses if cws.strftime("%Y-%m-%d") <= expense['date'] <= we.strftime("%Y-%m-%d")]
            if fe:
                display_expenses(fe, title=f"Week {wn} ({cws.strftime('%Y-%m-%d')} to {we.strftime('%Y-%m-%d')})")
            else:
                messagebox.showinfo("View Expenses", f"No expenses found for Week {wn} ({cws.strftime('%Y-%m-%d')} to {we.strftime('%Y-%m-%d')}).", parent=root)

            cws = we + timedelta(days=1)
            wn += 1

    elif period == 'monthly':
        mi = ask_string_input("View Expenses", "Enter the month (YYYY-MM):", root)
        if mi is None:
            return
        try:
            som = datetime.strptime(mi, "%Y-%m").replace(day=1)
            eom = (som + timedelta(days=31)).replace(day=1) - timedelta(days=1)
        except ValueError:
            messagebox.showerror("Error", "Invalid month format. Please enter the month in YYYY-MM format.", parent=root)
            return

        fe = [expense for expense in expenses if som.strftime("%Y-%m-%d") <= expense['date'] <= eom.strftime("%Y-%m-%d")]
        if not fe:
            messagebox.showinfo("View Expenses", f"No expenses found for {mi}.", parent=root)
            return

        display_expenses(fe, title=f"Expenses for {mi}")

    else:
        messagebox.showerror("Error", "Invalid period entered. Please enter 'daily', 'weekly', or 'monthly'.", parent=root)

def display_expenses(expenses_list, title="Expenses"):
    total_expense = sum(expense['amount'] for expense in expenses_list)
    summary = f"Total: ‚Çπ{total_expense:.2f}\n\n"

    cs = {}
    for expense in expenses_list:
        category = expense['category']
        if category in cs:
            cs[category] = cs[category] + expense['amount']
        else:
            cs[category] = expense['amount']

    summary += "Expenses by Category:\n"
    for category, amount in cs.items():
        summary += f"{category.capitalize()}: ‚Çπ{amount:.2f}\n"

    messagebox.showinfo(title, summary)

def manage_categories():
    global custom_categories
    while True:
        choice = ask_integer_input("Manage Categories", "1. Add Custom Category\n2. Edit Custom Category\n3. Remove Custom Category\n4. View All Categories\n5. Back to Main Menu", root)
        if choice is None:
            break

        if choice == 1:
            category_input = ask_string_input("Add Category", "Enter the name of the new category:", root)
            if category_input is None:
                continue
            category_name = category_input.strip().lower()
            if category_name in categories or category_name in custom_categories:
                messagebox.showerror("Error", "Category already exists.", parent=root)
            else:
                custom_categories[category_name] = 0
                messagebox.showinfo("Success", f"Category '{category_name}' added.", parent=root)

        elif choice == 2:
            if not custom_categories:
                messagebox.showinfo("Edit Category", "No custom categories to edit.", parent=root)
                continue
            category_list = list(custom_categories.keys())
            prompt = "\n".join([f"{idx + 1}. {category.capitalize()}" for idx, category in enumerate(category_list)])
            choice_num = ask_integer_input("Edit Category", prompt, root)
            if choice_num is None:
                continue
            index = choice_num - 1
            try:
                category_name = category_list[index]
                new_name_input = ask_string_input("Edit Category", f"Enter the new name for '{category_name}':", root)
                if new_name_input is None:
                    continue
                new_name = new_name_input.strip().lower()
                if new_name in categories or new_name in custom_categories:
                    messagebox.showerror("Error", "Category name already exists.", parent=root)
                else:
                    custom_categories[new_name] = custom_categories.pop(category_name)
                    messagebox.showinfo("Success", f"Category '{category_name}' renamed to '{new_name}'.", parent=root)
            except (ValueError, IndexError):
                messagebox.showerror("Error", "Invalid selection.", parent=root)

        elif choice == 3:
            if not custom_categories:
                messagebox.showinfo("Remove Category", "No custom categories to remove.", parent=root)
                continue
            category_list = list(custom_categories.keys())
            prompt = "\n".join([f"{idx + 1}. {category.capitalize()}" for idx, category in enumerate(category_list)])
            choice_num = ask_integer_input("Remove Category", prompt, root)
            if choice_num is None:
                continue
            index = choice_num - 1
            try:
                category_name = category_list[index]
                del custom_categories[category_name]
                messagebox.showinfo("Success", f"Category '{category_name}' removed.", parent=root)
            except (ValueError, IndexError):
                messagebox.showerror("Error", "Invalid selection.", parent=root)

        elif choice == 4:
            all_categories = {**categories, **custom_categories}
            category_text = "\n".join([f"{idx + 1}. {category.capitalize()}" for idx, category in enumerate(all_categories.keys())])
            messagebox.showinfo("All Categories", category_text, parent=root)

        elif choice == 5:
            break

        else:
            messagebox.showerror("Error", "Invalid option. Please choose a correct option.", parent=root)

def create_styled_button(parent, text, command, row, pady=10):
    """Create a styled button with hover effects"""
    btn = tk.Button(
        parent,
        text=text,
        command=command,
        bg=BUTTON_COLOR,
        fg="white",
        font=("Arial", 12, "bold"),
        relief="flat",
        padx=20,
        pady=12,
        cursor="hand2",
        activebackground=BUTTON_HOVER,
        activeforeground="white"
    )
    btn.grid(row=row, column=0, padx=40, pady=pady, sticky="ew")
    return btn

def ask_string_input(title, prompt, parent=None):
    """Create a styled string input dialog"""
    if parent is None:
        parent = root if 'root' in globals() else None
    dialog = tk.Toplevel(parent)
    dialog.title(title)
    dialog.geometry("400x150")
    dialog.configure(bg=BG_COLOR)
    dialog.resizable(False, False)
    dialog.transient(parent)
    dialog.grab_set()
    
    # Center the window
    dialog.update_idletasks()
    x = (dialog.winfo_screenwidth() // 2) - (400 // 2)
    y = (dialog.winfo_screenheight() // 2) - (150 // 2)
    dialog.geometry(f"400x150+{x}+{y}")
    
    result = [None]
    
    tk.Label(dialog, text=prompt, bg=BG_COLOR, fg=TEXT_COLOR, font=("Arial", 10)).pack(pady=15)
    
    entry = tk.Entry(dialog, font=("Arial", 11), width=30)
    entry.pack(pady=5)
    entry.focus()
    
    def on_ok():
        result[0] = entry.get()
        dialog.destroy()
    
    def on_cancel():
        dialog.destroy()
    
    button_frame = tk.Frame(dialog, bg=BG_COLOR)
    button_frame.pack(pady=10)
    
    ok_btn = tk.Button(button_frame, text="OK", command=on_ok, bg=BUTTON_COLOR, fg="white",
              font=("Arial", 10, "bold"), relief="flat", padx=20, pady=5,
              cursor="hand2", activebackground=BUTTON_HOVER, state="normal")
    ok_btn.pack(side=tk.LEFT, padx=5)
    
    cancel_btn = tk.Button(button_frame, text="Cancel", command=on_cancel, bg="#757575", fg="white",
              font=("Arial", 10), relief="flat", padx=20, pady=5,
              cursor="hand2", activebackground="#616161", state="normal")
    cancel_btn.pack(side=tk.LEFT, padx=5)
    
    entry.bind("<Return>", lambda e: on_ok())
    entry.bind("<Escape>", lambda e: on_cancel())
    
    dialog.wait_window()
    return result[0]

def ask_integer_input(title, prompt, parent=None):
    """Create a styled integer input dialog"""
    if parent is None:
        parent = root if 'root' in globals() else None
    dialog = tk.Toplevel(parent)
    dialog.title(title)
    dialog.geometry("400x150")
    dialog.configure(bg=BG_COLOR)
    dialog.resizable(False, False)
    dialog.transient(parent)
    dialog.grab_set()
    
    # Center the window
    dialog.update_idletasks()
    x = (dialog.winfo_screenwidth() // 2) - (400 // 2)
    y = (dialog.winfo_screenheight() // 2) - (150 // 2)
    dialog.geometry(f"400x150+{x}+{y}")
    
    result = [None]
    
    tk.Label(dialog, text=prompt, bg=BG_COLOR, fg=TEXT_COLOR, font=("Arial", 10), justify=tk.LEFT).pack(pady=15)
    
    entry = tk.Entry(dialog, font=("Arial", 11), width=30)
    entry.pack(pady=5)
    entry.focus()
    
    def on_ok():
        try:
            result[0] = int(entry.get())
            dialog.destroy()
        except ValueError:
            messagebox.showerror("Error", "Please enter a valid number.", parent=dialog)
    
    def on_cancel():
        dialog.destroy()
    
    button_frame = tk.Frame(dialog, bg=BG_COLOR)
    button_frame.pack(pady=10)
    
    ok_btn = tk.Button(button_frame, text="OK", command=on_ok, bg=BUTTON_COLOR, fg="white",
              font=("Arial", 10, "bold"), relief="flat", padx=20, pady=5,
              cursor="hand2", activebackground=BUTTON_HOVER, state="normal")
    ok_btn.pack(side=tk.LEFT, padx=5)
    
    cancel_btn = tk.Button(button_frame, text="Cancel", command=on_cancel, bg="#757575", fg="white",
              font=("Arial", 10), relief="flat", padx=20, pady=5,
              cursor="hand2", activebackground="#616161", state="normal")
    cancel_btn.pack(side=tk.LEFT, padx=5)
    
    entry.bind("<Return>", lambda e: on_ok())
    entry.bind("<Escape>", lambda e: on_cancel())
    
    dialog.wait_window()
    return result[0]

def show_main_window():
    """Create and show the main window"""
    global root
    
    root = tk.Tk()
    root.title("Expense Tracker")
    root.geometry(f"{WINDOW_WIDTH}x{WINDOW_HEIGHT}")
    root.configure(bg=BG_COLOR)
    root.resizable(False, False)
    
    # Center the window
    root.update_idletasks()
    x = (root.winfo_screenwidth() // 2) - (WINDOW_WIDTH // 2)
    y = (root.winfo_screenheight() // 2) - (WINDOW_HEIGHT // 2)
    root.geometry(f"{WINDOW_WIDTH}x{WINDOW_HEIGHT}+{x}+{y}")
    
    # Header
    header_frame = tk.Frame(root, bg=HEADER_COLOR, height=80)
    header_frame.pack(fill=tk.X)
    header_frame.pack_propagate(False)
    
    tk.Label(header_frame, text="üí∞ Expense Tracker", bg=HEADER_COLOR, fg="white",
             font=("Arial", 20, "bold")).pack(pady=25)
    
    # Main content frame
    content_frame = tk.Frame(root, bg=BG_COLOR)
    content_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=(20, 30))
    
    # Configure grid
    content_frame.grid_columnconfigure(0, weight=1)
    
    # Menu buttons
    create_styled_button(content_frame, "‚ûï Add Expense", lambda: am(), 0, pady=12)
    create_styled_button(content_frame, "üìä View Summary", lambda: vs(), 1, pady=12)
    create_styled_button(content_frame, "üìÖ View Expenses by Period", lambda: vep(), 2, pady=12)
    create_styled_button(content_frame, "üìÅ Manage Categories", lambda: manage_categories(), 3, pady=12)
    create_styled_button(content_frame, "üíæ Save and Exit", lambda: on_exit(), 4, pady=12)
    
    root.mainloop()

def on_exit():
    """Handle exit button click"""
    se()
    ete()
    root.quit()
    root.destroy()

if __name__ == "__main__":
    le()
    show_main_window()
